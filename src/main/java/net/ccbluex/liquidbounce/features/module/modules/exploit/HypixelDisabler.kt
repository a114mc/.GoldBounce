package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.MotionEvent
import net.ccbluex.liquidbounce.event.MovementInputEvent
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.modules.exploit.Disabler.getLobbyStatus
import net.ccbluex.liquidbounce.features.module.modules.exploit.Disabler.hypixelStatus
import net.ccbluex.liquidbounce.features.module.modules.exploit.Disabler.isReplay
import net.ccbluex.liquidbounce.features.module.modules.exploit.Disabler.nullCheck
import net.ccbluex.liquidbounce.utils.chat
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.FloatValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.minecraft.client.gui.ScaledResolution
import net.minecraftforge.event.entity.EntityJoinWorldEvent
import net.minecraftforge.fml.common.eventhandler.EventPriority
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import net.minecraftforge.fml.common.gameevent.TickEvent
import org.lwjgl.opengl.GL11.GL_BLEND
import org.lwjgl.opengl.GL11.GL_FLAT
import org.lwjgl.opengl.GL11.GL_ONE_MINUS_SRC_ALPHA
import org.lwjgl.opengl.GL11.GL_POLYGON
import org.lwjgl.opengl.GL11.GL_QUADS
import org.lwjgl.opengl.GL11.GL_SMOOTH
import org.lwjgl.opengl.GL11.GL_SRC_ALPHA
import org.lwjgl.opengl.GL11.GL_TEXTURE_2D
import org.lwjgl.opengl.GL11.glBegin
import org.lwjgl.opengl.GL11.glBlendFunc
import org.lwjgl.opengl.GL11.glColor4f
import org.lwjgl.opengl.GL11.glDisable
import org.lwjgl.opengl.GL11.glEnable
import org.lwjgl.opengl.GL11.glEnd
import org.lwjgl.opengl.GL11.glShadeModel
import org.lwjgl.opengl.GL11.glVertex2f
import java.awt.Color
import java.lang.Math.toRadians
import kotlin.math.cos
import kotlin.math.sin


object HypixelDisabler : Module("HypixelDisabler", Category.EXPLOIT) {

    private val hypixelMode by BoolValue("Hypixel", true)
    private val hypixelMotionMode by BoolValue("HypixelMotion", false)
    private val activationDelay by FloatValue("Activation delay", 0.0F, 0.0F..4.0F)
    private val resetDisabler = BoolValue("§cReset", false)

    private var tickCounter = 0
    private var waitingForGround = false
    private var applyingMotion = false
    private var stateTickCounter = 0
    private var warningDisplayed = false
    private var sprintToggleTick = 0
    private var shouldRun = false
    private var lobbyTime = 0L
    private var finished = 0L
    private var activationDelayMillis = 0L
    private var color = Color(0, 187, 255).rgb
    private var dotAnimationCounter = 0
    private var lastDotUpdate = 0L
    private var hasPrintedRunningMessage = false

    private val barWidth = 80f
    private val barHeight = 5f
    private var filledWidth = 0f
    private var barX = 0f
    private var barY = 0f
    private val borderColor = Color(30, 30, 30, 200).rgb
    private var inAirTicks = 0
    private var shouldRender = false
    private var firstY = 0.0
    private var reset = false
    private var savedYaw = 0f
    private var savedPitch = 0f
    private var worldJoin = false
    private var wDelay = 0

    var disablerLoaded = false
    var running = false


    override fun onEnable() {
        if (!disablerLoaded) {
            resetState()
        }

        val scaledResolution = ScaledResolution(mc)
        barX = scaledResolution.scaledWidth / 2f - barWidth / 2
        barY = scaledResolution.scaledHeight / 2f + 28
    }

    override fun onDisable() {
        shouldRun = false
        running = false
    }

    private fun resetState() {
        savedYaw = mc.thePlayer.rotationYaw
        savedPitch = mc.thePlayer.rotationPitch
        shouldRun = true
        tickCounter = 0
        applyingMotion = false
        waitingForGround = true
        stateTickCounter = 0
        warningDisplayed = false
        running = false
        sprintToggleTick = 0
        lobbyTime = System.currentTimeMillis()
        finished = 0
        shouldRender = false
        reset = false
        worldJoin = false
        activationDelayMillis = (activationDelay * 1000).toLong()
        hasPrintedRunningMessage = false
    }

    @SubscribeEvent
    fun onWorldJoin(event: EntityJoinWorldEvent) {
        if (event.entity == mc.thePlayer) {
            resetState()
        }
    }

    @EventTarget
    fun onPreMotion(event: MotionEvent) {
        if (mc.thePlayer.onGround) {
            inAirTicks = 0
        } else {
            inAirTicks++
        }
        if (event.eventState.stateName != "PRE") return
        if (resetDisabler.get()) {
            chat("Disabler resetting...")
            resetState()
            disablerLoaded = false
            resetDisabler.set(false)
        }

        if (getLobbyStatus() == 1 || hypixelStatus() != 1 || isReplay()) {
            return
        }

        val now = System.currentTimeMillis()
        if (finished != 0L && mc.thePlayer.onGround && now - finished > checkDisabledTime) {
            chat("Disabler enabled!")
            finished = 0
            filledWidth = 0f
            disablerLoaded = true
        }

        if (!shouldRun) {
            return
        }

        if (now - lobbyTime < activationDelayMillis) {
            return
        }

        running = true
        mc.thePlayer.rotationYaw = 0F
        mc.thePlayer.rotationPitch = savedPitch

        if (waitingForGround) {
            if (mc.thePlayer.onGround) {
                mc.thePlayer.motionY = 0.42
                waitingForGround = false
                worldJoin = false
            }
            return
        }

        if (inAirTicks >= 10 || worldJoin && ++wDelay >= 3) {
            if (!applyingMotion) {
                applyingMotion = true
                firstY = mc.thePlayer.posY
            }

            if (tickCounter < disablerTicks) {
                if (!hasPrintedRunningMessage) {
                    chat("running disabler...")
                    hasPrintedRunningMessage = true
                }
                shouldRender = true

                mc.thePlayer.motionX = 0.0
                mc.thePlayer.motionY = 0.0
                mc.thePlayer.motionZ = 0.0

                if (mc.thePlayer.posY != firstY) {
                    if (!reset) {
                        resetState()
                        activationDelayMillis = 2000
                        reset = true
                        chat("&7[&dR&7] &adisabler reset, wait a few seconds...")
                    } else {
                        shouldRun = false
                        applyingMotion = false
                        running = false
                        chat("&7[&dR&7] &cfailed to reset disabler, plz try again!")
                    }
                }

                if (mc.thePlayer.ticksExisted % 2 == 0) {
                    mc.thePlayer.posZ += 0.075
                    mc.thePlayer.posX += 0.075
                }

                tickCounter++
            } else if (!warningDisplayed) {
                val totalTimeSeconds = (now - lobbyTime) / 1000.0
                warningDisplayed = true
                finished = now
                shouldRender = false
                shouldRun = false
                applyingMotion = false
                running = false
            }
        }

        filledWidth = barWidth * tickCounter / disablerTicks
        val scaledResolution = ScaledResolution(mc)
        barX = scaledResolution.scaledWidth / 2f - barWidth / 2
        barY = scaledResolution.scaledHeight / 2f + 28
    }

    @EventTarget
    fun onMoveInput(event: MovementInputEvent) {
        if (!running || isReplay()) {
            return
        }
        event.originalInput.moveForward= 0f
        event.originalInput.moveStrafe = 0f
        mc.thePlayer.movementInput.jump = false
    }

    @SubscribeEvent
    fun onRenderTick(event: TickEvent.RenderTickEvent) {
        if (!nullCheck() || mc.currentScreen != null || !shouldRun || !shouldRender) {
            return
        }

        // 更新动画计时
        val currentTime = System.currentTimeMillis()
        if (currentTime - lastDotUpdate > 333) {
            dotAnimationCounter = (dotAnimationCounter + 1) % 4
            lastDotUpdate = currentTime
        }

        color = Color.YELLOW.rgb
        val baseText = "Watchdog Sleeping"

        // 生成动态省略号
        val dots = when (dotAnimationCounter) {
            1 -> "."
            2 -> ".."
            3 -> "..."
            4 -> "...."
            else -> ""
        }

        val fullText = baseText + dots
        val textWidth = mc.fontRendererObj.getStringWidth(fullText)
        val sr = ScaledResolution(mc)

        // 绘制文字
        val xPos = (sr.scaledWidth - textWidth) / 2
        val yPos = sr.scaledHeight / 2 + 8
        mc.fontRendererObj.drawStringWithShadow(fullText, xPos.toFloat(), yPos.toFloat(), color)

        // 绘制进度条
        if (tickCounter > 0) {
            // 背景阴影
            drawRoundedRect(barX - 1, barY - 1, barX + barWidth + 1, barY + barHeight + 1, 3F, 0xAA000000.toInt())

            // 背景条
            drawRoundedRect(barX, barY, barX + barWidth, barY + barHeight, 2F, 0xAA222222.toInt())

            // 渐变填充条
            drawGradientRect(
                barX + 0.5f,
                barY + 0.5f,
                barX + filledWidth - 0.5f,
                barY + barHeight - 0.5f,
                color,
                adjustColor(color, -50)
            )

            // 高光边框
            drawRoundedRect(barX, barY, barX + barWidth, barY + barHeight, 2F, 0x44FFFFFF)
        }
    }

    private fun drawRoundedRect(x: Float, y: Float, x2: Float, y2: Float, radius: Float, color: Int) {
        glEnable(GL_BLEND)
        glDisable(GL_TEXTURE_2D)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

        val alpha = (color shr 24 and 0xFF) / 255.0f
        val red = (color shr 16 and 0xFF) / 255.0f
        val green = (color shr 8 and 0xFF) / 255.0f
        val blue = (color and 0xFF) / 255.0f
        glColor4f(red, green, blue, alpha)

        glBegin(GL_POLYGON)
        for (i in 0..90 step 30) {
            val rad = toRadians(i.toDouble()).toFloat()
            glVertex2f(x + radius + cos(rad) * radius, y + radius + sin(rad) * radius)
        }
        for (i in 90..180 step 30) {
            val rad = toRadians(i.toDouble()).toFloat()
            glVertex2f(x2 - radius + cos(rad) * radius, y + radius + sin(rad) * radius)
        }
        for (i in 180..270 step 30) {
            val rad = toRadians(i.toDouble()).toFloat()
            glVertex2f(x2 - radius + cos(rad) * radius, y2 - radius + sin(rad) * radius)
        }
        for (i in 270..360 step 30) {
            val rad = toRadians(i.toDouble()).toFloat()
            glVertex2f(x + radius + cos(rad) * radius, y2 - radius + sin(rad) * radius)
        }
        glEnd()

        glEnable(GL_TEXTURE_2D)
        glDisable(GL_BLEND)
    }

    private fun drawGradientRect(left: Float, top: Float, right: Float, bottom: Float, startColor: Int, endColor: Int) {
        glEnable(GL_BLEND)
        glDisable(GL_TEXTURE_2D)
        glShadeModel(GL_SMOOTH)

        glBegin(GL_QUADS)
        // 起始颜色
        glColor4f(
            (startColor shr 16 and 0xFF) / 255.0f,
            (startColor shr 8 and 0xFF) / 255.0f,
            (startColor and 0xFF) / 255.0f,
            (startColor shr 24 and 0xFF) / 255.0f
        )
        glVertex2f(left, top)
        glVertex2f(left, bottom)

        // 结束颜色
        glColor4f(
            (endColor shr 16 and 0xFF) / 255.0f,
            (endColor shr 8 and 0xFF) / 255.0f,
            (endColor and 0xFF) / 255.0f,
            (endColor shr 24 and 0xFF) / 255.0f
        )
        glVertex2f(right, bottom)
        glVertex2f(right, top)
        glEnd()

        glShadeModel(GL_FLAT)
        glEnable(GL_TEXTURE_2D)
        glDisable(GL_BLEND)
    }

    private fun adjustColor(original: Int, amount: Int): Int {
        val r = (original shr 16 and 0xFF) + amount
        val g = (original shr 8 and 0xFF) + amount
        val b = (original and 0xFF) + amount
        return (original and 0xFF000000.toInt()) or
                (r.coerceIn(0, 255) shl 16 or
                        (g.coerceIn(0, 255) shl 8 or
                                b.coerceIn(0, 255)))
    }

    private val disablerTicks: Int
        get() = if (hypixelMode) 130 else 140

    private const val checkDisabledTime: Long = 4000
}